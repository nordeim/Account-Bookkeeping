# File: tests/unit/services/test_sequence_service.py
import pytest
from unittest.mock import AsyncMock, MagicMock
from typing import Optional
import datetime

from app.services.core_services import SequenceService
from app.models.core.sequence import Sequence as SequenceModel
from app.core.database_manager import DatabaseManager

# Mark all tests in this module as asyncio
pytestmark = pytest.mark.asyncio

@pytest.fixture
def mock_session() -> AsyncMock:
    """Fixture to create a mock AsyncSession."""
    session = AsyncMock()
    session.get = AsyncMock() # Not directly used by SequenceService, but good for generic mock
    session.execute = AsyncMock()
    session.add = MagicMock()
    session.flush = AsyncMock()
    session.refresh = AsyncMock()
    return session

@pytest.fixture
def mock_db_manager(mock_session: AsyncMock) -> MagicMock:
    """Fixture to create a mock DatabaseManager that returns the mock_session."""
    db_manager = MagicMock(spec=DatabaseManager)
    db_manager.session.return_value.__aenter__.return_value = mock_session
    db_manager.session.return_value.__aexit__.return_value = None
    return db_manager

@pytest.fixture
def sequence_service(mock_db_manager: MagicMock) -> SequenceService:
    """Fixture to create a SequenceService instance with a mocked db_manager."""
    return SequenceService(db_manager=mock_db_manager)

# Sample Data
@pytest.fixture
def sample_sequence_orm() -> SequenceModel:
    return SequenceModel(
        id=1,
        sequence_name="SALES_INVOICE",
        prefix="INV-",
        next_value=101,
        increment_by=1,
        min_value=1,
        max_value=999999,
        cycle=False,
        format_template="{PREFIX}{VALUE:06d}" 
    )

# --- Test Cases ---

async def test_get_sequence_by_name_found(
    sequence_service: SequenceService, 
    mock_session: AsyncMock, 
    sample_sequence_orm: SequenceModel
):
    """Test get_sequence_by_name when the sequence is found."""
    mock_execute_result = AsyncMock()
    mock_execute_result.scalars.return_value.first.return_value = sample_sequence_orm
    mock_session.execute.return_value = mock_execute_result

    result = await sequence_service.get_sequence_by_name("SALES_INVOICE")
    
    assert result == sample_sequence_orm
    mock_session.execute.assert_awaited_once()
    # We could inspect the statement passed to execute if needed
    # e.g., call_args[0][0].compile(compile_kwargs={"literal_binds": True})

async def test_get_sequence_by_name_not_found(
    sequence_service: SequenceService, 
    mock_session: AsyncMock
):
    """Test get_sequence_by_name when the sequence is not found."""
    mock_execute_result = AsyncMock()
    mock_execute_result.scalars.return_value.first.return_value = None
    mock_session.execute.return_value = mock_execute_result

    result = await sequence_service.get_sequence_by_name("NON_EXISTENT_SEQ")
    
    assert result is None
    mock_session.execute.assert_awaited_once()

async def test_save_sequence(
    sequence_service: SequenceService, 
    mock_session: AsyncMock, 
    sample_sequence_orm: SequenceModel
):
    """Test saving a Sequence object."""
    
    # Simulate ORM behavior where refresh might update the object (e.g., timestamps)
    async def mock_refresh(obj, attribute_names=None):
        obj.updated_at = datetime.datetime.now(datetime.timezone.utc) # Simulate timestamp update
        if not obj.created_at:
            obj.created_at = datetime.datetime.now(datetime.timezone.utc)
        # If ID were autogenerated and None before save, it would be set here.
        # But for Sequence, sequence_name is unique key and ID is serial.
    mock_session.refresh.side_effect = mock_refresh

    sequence_to_save = sample_sequence_orm
    result = await sequence_service.save_sequence(sequence_to_save)

    mock_session.add.assert_called_once_with(sequence_to_save)
    mock_session.flush.assert_awaited_once()
    mock_session.refresh.assert_awaited_once_with(sequence_to_save)
    assert result == sequence_to_save
    assert result.updated_at is not None # Check that refresh side_effect worked

async def test_save_new_sequence_object(
    sequence_service: SequenceService, 
    mock_session: AsyncMock
):
    """Test saving a brand new Sequence object instance."""
    new_sequence = SequenceModel(
        sequence_name="TEST_SEQ",
        prefix="TS-",
        next_value=1,
        increment_by=1,
        format_template="{PREFIX}{VALUE:04d}"
    )
    
    async def mock_refresh_new(obj, attribute_names=None):
        obj.id = 123 # Simulate ID generation
        obj.created_at = datetime.datetime.now(datetime.timezone.utc)
        obj.updated_at = datetime.datetime.now(datetime.timezone.utc)
    mock_session.refresh.side_effect = mock_refresh_new

    result = await sequence_service.save_sequence(new_sequence)

    mock_session.add.assert_called_once_with(new_sequence)
    mock_session.flush.assert_awaited_once()
    mock_session.refresh.assert_awaited_once_with(new_sequence)
    assert result.id == 123
    assert result.prefix == "TS-"
